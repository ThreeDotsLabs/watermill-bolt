package bolt

import (
	"bytes"
	"context"
	"time"

	"github.com/boreq/errors"
	"go.etcd.io/bbolt"
)

// DelayedBoltSubscriber extends the regular Subscriber to handle delayed
// messages. It only retrieves messages whose scheduled time has arrived,
// based on the message keys stored as RFC3339 timestamps.
type DelayedBoltSubscriber struct {
	*Subscriber
}

// NewDelayedSubscriber creates an initialized delayed subscriber that only
// delivers messages when their scheduled time has arrived.
func NewDelayedSubscriber(db *bbolt.DB, config SubscriberConfig) (*DelayedBoltSubscriber, error) {
	subscriber, err := NewSubscriber(db, config)
	if err != nil {
		return nil, errors.Wrap(err, "failed to create underlying subscriber")
	}

	subscriber.loadMsgsFn = getMessagesWithDelay

	return &DelayedBoltSubscriber{
		subscriber,
	}, nil
}

func getMessagesWithDelay(_ context.Context, s *Subscriber, topic string) ([]rawMessage, error) {
	var messages []rawMessage

	if err := s.db.View(func(tx *bbolt.Tx) error {
		bucket := s.getSubscriptionBucket(tx, topic)
		if bucket == nil {
			return nil
		}

		c := bucket.Cursor()
		now := []byte(time.Now().UTC().Format(time.RFC3339))

		// k[:len(now)] used to cut uuid postfix of key generated by timeBasedKey for comparison
		for k, v := c.First(); k != nil && bytes.Compare(k[:len(now)], now) <= 0; k, v = c.Next() {
			messages = append(messages, newRawMessage(k, v))
		}

		return nil
	}); err != nil {
		return nil, errors.Wrap(err, "transaction failed")
	}

	return messages, nil
}
